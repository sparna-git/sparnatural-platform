import axios from "axios";
import { SparnaturalQuery } from "../zod/query";
import { z } from "zod";
import config from "../config/config";
import { EmptyRequestError } from "../errors/emptyRequestError";

// Set Mistral agent IDs from config
const agentIdQueryToText =
  config["projects"]["dbpedia-en"]["endpoints-agents"][
    "MISTRAL_AGENT_ID_query_2_text"
  ];
const agentIdTextToQuery =
  config["projects"]["dbpedia-en"]["endpoints-agents"][
    "MISTRAL_AGENT_ID_text_2_query"
  ];

/**
 * G√©n√®re un r√©sum√© textuel √† partir d'une requ√™te Sparnatural JSON.
 * @param jsonQuery - La requ√™te JSON au format SparnaturalQueryIfc
 * @param lang - La langue du r√©sum√© attendu (ex : "fr", "en")
 * @returns Un texte r√©sum√© g√©n√©r√© par l'agent
 */
export async function getSummaryFromAgent(
  jsonQuery: object,
  lang: string
): Promise<string> {
  try {
    const messageContent = `LANGUAGE: ${lang}\n\nQUERY:\n${JSON.stringify(
      jsonQuery,
      null,
      2
    )}`;

    const response = await axios.post(
      "https://api.mistral.ai/v1/agents/completions",
      {
        agent_id: agentIdQueryToText,
        messages: [{ role: "user", content: messageContent }],
        response_format: { type: "text" },
      },
      {
        headers: {
          Authorization: `Bearer ${process.env.MISTRAL_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    const result = response.data.choices?.[0]?.message?.content;
    return result || "R√©ponse vide du mod√®le Mistral.";
  } catch (error: any) {
    console.error(
      "Erreur Mistral (getSummaryFromAgent) :",
      error?.response?.data || error.message
    );
    return "Erreur lors de la g√©n√©ration du r√©sum√© avec Mistral.";
  }
}
const tools = [
  {
    type: "function",
    function: {
      name: "reconciliation",
      description: "Resolve a label and type into an RDF URI",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "The label to look up (e.g., 'France')",
          },
        },
        required: ["name"],
      },
    },
  },
];

export async function getJsonFromAgent(
  naturalLanguageQuery: string,
  projectKey: string
): Promise<z.infer<typeof SparnaturalQuery>> {
  const messageContent = naturalLanguageQuery;
  const userMessage = { role: "user", content: messageContent };

  function extractJsonFromMarkdown(text: string): string {
    return text.replace(/^```json\s*/, "").replace(/\s*```$/, "");
  }

  console.log("[getJsonFromAgent] D√©but de la fonction");
  console.log("[getJsonFromAgent] Message utilisateur :", messageContent);

  try {
    console.log("[getJsonFromAgent] üîÅ Envoi de la 1re requ√™te √† Mistral");
    const firstResponse = await axios.post(
      "https://api.mistral.ai/v1/agents/completions",
      {
        agent_id: agentIdTextToQuery,
        messages: [userMessage],
        tools,
        tool_choice: "auto",
        response_format: { type: "text" },
      },
      {
        headers: {
          Authorization: `Bearer ${process.env.MISTRAL_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    const firstChoice = firstResponse.data.choices?.[0];
    const toolCalls = firstChoice?.message?.tool_calls;

    console.log(
      "[getJsonFromAgent] üß† Re√ßu :",
      JSON.stringify(firstChoice, null, 2)
    );

    if (toolCalls && toolCalls.length > 0) {
      console.log(
        `[getJsonFromAgent] üõ†Ô∏è ${toolCalls.length} outil(s) d√©tect√©(s)`
      );

      // Regrouper tous les appels uriLookup
      const uriLookupBody: Record<string, { query: string }> = {};

      for (const toolCall of toolCalls) {
        if (toolCall.function.name === "reconciliation") {
          const args = JSON.parse(toolCall.function.arguments);
          console.log("[getJsonFromAgent] üì§ reconciliation args :", args);
          uriLookupBody[toolCall.id] = { query: args.name };
        }
      }

      const uriRes = await axios.post(
        `http://localhost:3000/api/v1/${projectKey}/reconciliation`,
        uriLookupBody
      );

      console.log(
        "[getJsonFromAgent] ‚úÖ R√©sultat reconciliation :",
        JSON.stringify(uriRes.data, null, 2)
      );

      const toolResponses = Object.entries(uriRes.data).map(
        ([toolCallId, result]) => ({
          role: "tool",
          tool_call_id: toolCallId,
          name: "reconciliation",
          content: JSON.stringify(result),
        })
      );

      const assistantMessage = {
        role: "assistant",
        content: "R√©sultats des tool calls r√©solus.",
        tool_calls: toolCalls,
      };

      console.log(
        "[getJsonFromAgent] üîÅ Envoi de la 2e requ√™te √† Mistral apr√®s tous les reconciliation"
      );

      const secondResponse = await axios.post(
        "https://api.mistral.ai/v1/agents/completions",
        {
          agent_id: agentIdTextToQuery,
          messages: [userMessage, assistantMessage, ...toolResponses],
          response_format: { type: "text" },
        },
        {
          headers: {
            Authorization: `Bearer ${process.env.MISTRAL_API_KEY}`,
            "Content-Type": "application/json",
          },
        }
      );

      const raw = secondResponse.data.choices?.[0]?.message?.content;
      console.log("[getJsonFromAgent] üì• R√©ponse brute 2e appel :", raw);

      if (!raw || raw.trim() === "") {
        throw new Error("R√©ponse vide apr√®s appel outil");
      }

      const rawClean = extractJsonFromMarkdown(raw);
      const parsed = JSON.parse(rawClean);

      if (
        "error" in parsed &&
        (typeof parsed.error === "string" || typeof parsed.error === "object")
      ) {
        console.warn(
          "[getJsonFromAgent] ‚ö†Ô∏è Erreur retourn√©e par l'agent :",
          parsed.error
        );
        throw new EmptyRequestError(
          typeof parsed.error === "string"
            ? parsed.error
            : parsed.error.message || "Erreur de g√©n√©ration de la requ√™te JSON"
        );
      }

      const validated = SparnaturalQuery.parse(parsed);
      console.log("[getJsonFromAgent] ‚úÖ JSON valid√© apr√®s outil :", validated);
      return validated;
    } else {
      console.log("[getJsonFromAgent] ‚ö†Ô∏è Pas de toolCalls ‚Äì r√©ponse directe");

      const raw = firstChoice?.message?.content;
      console.log("[getJsonFromAgent] üì• R√©ponse brute sans outil :", raw);

      if (!raw || raw.trim() === "") {
        throw new Error("R√©ponse vide sans outil");
      }

      const rawClean = extractJsonFromMarkdown(raw);
      const parsed = JSON.parse(rawClean);

      if (
        "error" in parsed &&
        (typeof parsed.error === "string" || typeof parsed.error === "object")
      ) {
        console.warn(
          "[getJsonFromAgent] ‚ö†Ô∏è Erreur retourn√©e par l'agent :",
          parsed.error
        );
        throw new EmptyRequestError(
          typeof parsed.error === "string"
            ? parsed.error
            : parsed.error.message || "Erreur de g√©n√©ration de la requ√™te JSON"
        );
      }

      console.log("[getJsonFromAgent] üì¶ JSON extrait :", parsed);
      const validated = SparnaturalQuery.parse(parsed);
      console.log("[getJsonFromAgent] ‚úÖ JSON valid√© sans outil :", validated);
      return validated;
    }
  } catch (error: any) {
    if (error instanceof EmptyRequestError) {
      throw error;
    }

    if (error?.response?.data) {
      console.error(
        "[getJsonFromAgent] ‚ùå Erreur axios :",
        JSON.stringify(error.response.data, null, 2)
      );
    } else {
      console.error("[getJsonFromAgent] ‚ùå Erreur :", error.message || error);
    }

    throw new Error("Erreur lors de la g√©n√©ration ou validation du JSON");
  }
}
